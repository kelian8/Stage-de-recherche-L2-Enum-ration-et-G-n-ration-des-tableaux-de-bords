02/06/2025
Réapropriation des documents, lecture et compréhension des documents.
Rédactions d'un récapitulatif simplifier des documents pour une meilleure assimilation de ces derniers.
Début de l'analyse des algos (entrée, sortie, fonctionnement/comportement attendu).

03/06/2025
Création de mon github
Suite de l'analyse des algos (entrée, sortie, fonctionnement/comportement attendu).
Création de l'algorithme "BorderToTableprefixe" en pseudo code.
Début des implémentations des algorithmes en c.

04/06/2025
Apprentissage c++.
changement du matériel défectueux (souris).
prise en main de c++.
Implementation du premiere algo TablepréfixeToListepréfixe.
Création d'un petit programme main pour tester mes autres programmes.
Réalisation de tests de TablepréfixeToListepréfixe.

05/06/2025
Implmémentation du code BorderToListeprefixe.
Ajout de commentaire à TablepréfixeToListepréfixe.
Ajout de commentaire à BorderToListeprefixe.
rassemblement des programmes dans un seul fichier appelé package_outils.cpp .
ajout de la fonction nobord.
ajout de la fonction creaAlph qui créer un alphabet de n lettres.

06/06/2025
Implémentation de la fonction LPtoWord qui prend en entrée une liste de préfixe et un alphabet et qui donne en sortie un mot .
Problème rencontré lors des tests, fonctionnement innatendu, début analyse et recherche du problème.

10/06/2025
Absence rattrapage.

11/06/2025
suite de la recherche du problème .
résolution du problème, erreur dans le document scientifique,après plusieurs tests et investigation et réanalyse de la fonction, j'ai remarqué que la fonction transforme en fait une table de bordure en mot et non une liste de préfixe en mot.
Correction apporté au code.
Ajout de commentaires à la fonction TBtoWord.

12/06/2025
Compréhension de la propriété récursive pour la construction d'une table de bordure.
Début codage d'une première fonction WtoB en utilisant la propriété.

13/06/2025
Fin codage de BtoW en utilisant la propriété récursive
Ajout commentaire a BtoW

16/06/2025
codage de LtoMinW qui prend une liste de prefixe et renvoit un mot contenant le moisn de lettres differentes possible
et de Border 
correction de bugs sur ces fonctions

17/06/2025
Fin du codage et du débogage de LtoMinW c'était pas facile, j'ai du cherché longtemps.
Tests de la fonction LtoMinW.

18/06/2025
Début analyse des nouvelles questions : 
1. pour un mot p-canonique u donné de longueur n, et un alphabet de
taille s, déterminer une formule qui compte le nombres de mots de n
(parmi les s^n mots possibles) qui sont dans la classe du mot u. Pour
cela réflêchir aux positions du mot u pour lesquels vous pouvez choisir
la lettre et au nombre de lettres possibles.
   
2. un algo ou formule pour calculer combien de mots p-canoniques ont
le même border array (c'est à dire sont dans la même classe de
b-équivalence -- autrement dit sont liés au même mot b-canonique).
Travail sur papier avec des exemples.

19/06/2025
Suite des études sur la questions 1, pas beaucoup d'avancées hier, si ce n'est que les facteurs les plus important à mon avis sont la taille de l'alphabet ainsi que le nombre de lettres différents présentes dans le mot.
La formule pour la question 1 est : pour un mot p-canonnique de v lettres différentes et un alphabet de x lettres, avec x>=v, il y a x!/(x-v)!  .
En effet, pour le choix de la première lettre on a x possibilités, pour le choix de la seconde lettre différente on a x-1 possibilités jusqu'à arriver à la v-ième lettre differente.
Si x=v on a alors x*x-1*...*1 et pour x>v on a alors x*x-1*...*x-v+1 , ce qui illustre bien la formule x!/(x-v)! .
La longueur du mot n'a pas d'importance, seulement le nombre de lettres differentes contenues.
J'ai mis du temps pour trouver un résultat si simple car j'avais commis une erreur sur le dénombrement lors d'un de mes exemples, en réalité j'avais deja la bonne formule,
mais comme mon exemple était faux la formule me semblait fausse car elle renvoyait un résultat different de mon dénombrement manuel.
Pourtant le raisonnement me semblait etre le bon, j'ai alors revérifier mon exemple (chose que j'aurai du faire plus tot). 

20/06/2025
Début de l'étude de la question 2.
Correction de TBtoWord qui est en LPToWord et qui transforme bien une liste de prefixe en un mot et non un tableau en un mot.
Le probleme venait d'une condition trop restrictive dans nobord, ce qui resultait un a mauvais resultat final de LPTo word.
Je me suis rendu compte de se problème en utilisant la fonction TBtoWord pour repondre a la question 2.
J'ai donc du mettre de coté l'étude de la question 2, pour corriger mon code.
Reprise de l'étude de la question 2.
